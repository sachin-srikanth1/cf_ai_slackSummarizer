import os
import logging
from typing import Dict, Any, Optional
from datetime import datetime
from reportlab.lib.pagesizes import letter, A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak, Table, TableStyle
from reportlab.lib.colors import HexColor, black, white
from reportlab.lib.enums import TA_LEFT, TA_CENTER, TA_JUSTIFY
# import markdown  # Not currently used
import re

logger = logging.getLogger(__name__)

class PDFService:
    def __init__(self):
        self.output_dir = os.getenv("PDF_OUTPUT_DIR", "./reports")
        os.makedirs(self.output_dir, exist_ok=True)

    async def create_summary_pdf(
        self, 
        summary: str, 
        summary_type: str, 
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """Create a PDF report from summary text"""
        try:
            # Generate filename
            timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
            filename = f"{summary_type.lower()}_summary_{timestamp}.pdf"
            filepath = os.path.join(self.output_dir, filename)
            
            # Create PDF document
            doc = SimpleDocTemplate(
                filepath,
                pagesize=A4,
                topMargin=1*inch,
                bottomMargin=1*inch,
                leftMargin=0.75*inch,
                rightMargin=0.75*inch
            )
            
            # Build content
            story = []
            styles = getSampleStyleSheet()
            
            # Add custom styles
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Title'],
                fontSize=24,
                textColor=HexColor('#2C3E50'),
                spaceAfter=30,
                alignment=TA_CENTER
            )
            
            heading_style = ParagraphStyle(
                'CustomHeading',
                parent=styles['Heading1'],
                fontSize=16,
                textColor=HexColor('#34495E'),
                spaceBefore=20,
                spaceAfter=10
            )
            
            subheading_style = ParagraphStyle(
                'CustomSubheading',
                parent=styles['Heading2'],
                fontSize=14,
                textColor=HexColor('#7F8C8D'),
                spaceBefore=15,
                spaceAfter=8
            )
            
            body_style = ParagraphStyle(
                'CustomBody',
                parent=styles['Normal'],
                fontSize=11,
                textColor=black,
                spaceAfter=12,
                alignment=TA_JUSTIFY
            )
            
            # Add title
            title_text = f"{summary_type} Summary Report"
            story.append(Paragraph(title_text, title_style))
            story.append(Spacer(1, 20))
            
            # Add metadata table
            if metadata:
                story.append(self._create_metadata_table(metadata, styles))
                story.append(Spacer(1, 20))
            
            # Process and add summary content
            summary_content = self._process_summary_content(
                summary, 
                heading_style, 
                subheading_style, 
                body_style
            )
            story.extend(summary_content)
            
            # Add footer info
            story.append(PageBreak())
            story.append(Paragraph("Generated by Slack AI Summarizer", styles['Normal']))
            story.append(Paragraph(f"Report created: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}", styles['Normal']))
            
            # Build PDF
            doc.build(story)
            
            logger.info(f"PDF report created: {filepath}")
            return filepath
            
        except Exception as e:
            logger.error(f"Error creating PDF: {e}")
            raise Exception(f"Failed to create PDF: {e}")

    def _create_metadata_table(self, metadata: Dict[str, Any], styles) -> Table:
        """Create a metadata table for the PDF header"""
        data = [
            ['Report Type', metadata.get('summary_type', 'Unknown')],
            ['Generated At', metadata.get('generated_at', datetime.utcnow().isoformat())],
            ['Message Count', str(metadata.get('message_count', 0))],
            ['Channels', ', '.join(metadata.get('channels', []))]
        ]
        
        table = Table(data, colWidths=[2*inch, 4*inch])
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), HexColor('#ECF0F1')),
            ('TEXTCOLOR', (0, 0), (-1, 0), black),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 12),
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 1), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), white),
            ('GRID', (0, 0), (-1, -1), 1, HexColor('#BDC3C7'))
        ]))
        
        return table

    def _process_summary_content(self, summary: str, heading_style, subheading_style, body_style):
        """Process markdown-like summary content into PDF elements"""
        story = []
        lines = summary.split('\n')
        current_paragraph = []
        
        for line in lines:
            line = line.strip()
            
            if not line:
                # Empty line - end current paragraph
                if current_paragraph:
                    text = ' '.join(current_paragraph)
                    story.append(Paragraph(text, body_style))
                    current_paragraph = []
                continue
            
            # Check for headers
            if line.startswith('## '):
                # Finish current paragraph
                if current_paragraph:
                    text = ' '.join(current_paragraph)
                    story.append(Paragraph(text, body_style))
                    current_paragraph = []
                
                # Add heading
                heading_text = line[3:].strip()
                story.append(Paragraph(heading_text, heading_style))
                continue
            
            elif line.startswith('### '):
                # Finish current paragraph
                if current_paragraph:
                    text = ' '.join(current_paragraph)
                    story.append(Paragraph(text, body_style))
                    current_paragraph = []
                
                # Add subheading
                subheading_text = line[4:].strip()
                story.append(Paragraph(subheading_text, subheading_style))
                continue
            
            elif line.startswith('- ') or line.startswith('* '):
                # Finish current paragraph
                if current_paragraph:
                    text = ' '.join(current_paragraph)
                    story.append(Paragraph(text, body_style))
                    current_paragraph = []
                
                # Add bullet point
                bullet_text = f"â€¢ {line[2:].strip()}"
                story.append(Paragraph(bullet_text, body_style))
                continue
            
            else:
                # Regular text - add to current paragraph
                current_paragraph.append(line)
        
        # Finish any remaining paragraph
        if current_paragraph:
            text = ' '.join(current_paragraph)
            story.append(Paragraph(text, body_style))
        
        return story

    def _clean_text_for_pdf(self, text: str) -> str:
        """Clean text for PDF generation"""
        # Remove or escape problematic characters
        text = text.replace('&', '&amp;')
        text = text.replace('<', '&lt;')
        text = text.replace('>', '&gt;')
        
        # Handle emoji and special characters
        text = re.sub(r'[^\x00-\x7F]+', '', text)  # Remove non-ASCII
        
        return text

    async def create_comparison_pdf(
        self, 
        current_summary: str, 
        previous_summary: str, 
        summary_type: str
    ) -> str:
        """Create a PDF comparing current and previous summaries"""
        try:
            timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
            filename = f"{summary_type.lower()}_comparison_{timestamp}.pdf"
            filepath = os.path.join(self.output_dir, filename)
            
            doc = SimpleDocTemplate(filepath, pagesize=A4)
            story = []
            styles = getSampleStyleSheet()
            
            # Title
            title = f"{summary_type} Summary Comparison"
            story.append(Paragraph(title, styles['Title']))
            story.append(Spacer(1, 20))
            
            # Current summary section
            story.append(Paragraph("Current Period Summary", styles['Heading1']))
            story.append(Spacer(1, 10))
            
            current_content = self._process_summary_content(
                current_summary, 
                styles['Heading2'], 
                styles['Heading3'], 
                styles['Normal']
            )
            story.extend(current_content)
            
            story.append(PageBreak())
            
            # Previous summary section
            story.append(Paragraph("Previous Period Summary", styles['Heading1']))
            story.append(Spacer(1, 10))
            
            previous_content = self._process_summary_content(
                previous_summary, 
                styles['Heading2'], 
                styles['Heading3'], 
                styles['Normal']
            )
            story.extend(previous_content)
            
            doc.build(story)
            
            logger.info(f"Comparison PDF created: {filepath}")
            return filepath
            
        except Exception as e:
            logger.error(f"Error creating comparison PDF: {e}")
            raise Exception(f"Failed to create comparison PDF: {e}")

    async def get_pdf_info(self, filepath: str) -> Dict[str, Any]:
        """Get information about a PDF file"""
        try:
            if not os.path.exists(filepath):
                return {"exists": False}
            
            stat = os.stat(filepath)
            return {
                "exists": True,
                "size": stat.st_size,
                "created": datetime.fromtimestamp(stat.st_ctime).isoformat(),
                "modified": datetime.fromtimestamp(stat.st_mtime).isoformat(),
                "filename": os.path.basename(filepath)
            }
        except Exception as e:
            logger.error(f"Error getting PDF info: {e}")
            return {"exists": False, "error": str(e)}

    async def cleanup_old_pdfs(self, days_old: int = 30) -> Dict[str, Any]:
        """Clean up PDF files older than specified days"""
        try:
            cutoff_time = datetime.utcnow().timestamp() - (days_old * 24 * 60 * 60)
            deleted_count = 0
            total_size_freed = 0
            
            for filename in os.listdir(self.output_dir):
                if filename.endswith('.pdf'):
                    filepath = os.path.join(self.output_dir, filename)
                    stat = os.stat(filepath)
                    
                    if stat.st_mtime < cutoff_time:
                        total_size_freed += stat.st_size
                        os.remove(filepath)
                        deleted_count += 1
                        logger.info(f"Deleted old PDF: {filename}")
            
            return {
                "deleted_count": deleted_count,
                "size_freed_bytes": total_size_freed,
                "size_freed_mb": round(total_size_freed / (1024 * 1024), 2)
            }
            
        except Exception as e:
            logger.error(f"Error cleaning up PDFs: {e}")
            return {"error": str(e)}